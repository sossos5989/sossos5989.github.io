---
title: "[운영체제] 프로세스"
date: "2025-04-17T03:00:00+09:00"
tags: ["학부생활", "운영체제"]
categories: 
  - 학부생활
  - 운영체제
description: "운영체제 프로세스 정리입니다."
layout: "post"
published: true
# image: "/images/sample.jpg"
comments: true
---

## 프로세스
### 프로세스 정의
> 프로세스: 실행 단계인 프로그램

### 프로세스의 구성요소
프로세스는 3가지의 구성 요소를 가지고 있습니다.

1. executable program: 실행 가능한 프로그램으로 코드 등이 있습니다.
2. data: 실행 프로그램이 처리해야 할 대상 정보입니다.
3. execution context: 컴퓨팅 자원 집합

### 프로세스와 하드웨어
간략하게 설명하자면, 메인 메모리 커널 안에 dispatcher라는게 존재 해, 이게 실행 능한 프로세스에게 cpu를 배정하고, 프로세스 실행 준비 역할을 담당함.

프로그램은 instruction의 sequence로 구성되어져, 프로세스의 상태를 정의하고 이를 적절하게 메모리에 로드해야 합니다.

이때, 버스를 통해서 메인메모리 <-> process끼리 program counter를 이용해 연속적으로 instruction을 메인 메모리로부터 읽어올 수 있습니다.

### 프로세스의 생성 원리
프로세스가 만들어지는 경우는 총 3개라고 볼 수 있습니다.

1. 운영체제가 부팅하면서 서비스 프로세스를 생성하고, 커널 안에 다 생성하는게 아닌 일종의 프로그램 형태로 위임하는 식(백그라운드 동작)으로 이를 **daemon process**라고 합니다.
2. 이미 있는 프로세스가 자기 자식 프로세스를 만듦. 운영체제에게 요청하여 만들어짐
3. user command, process 생성 (사람이 만듬)

### 프로세스의 종료 원인
프로세스의 종료 원인은 총 4개가 있습니다.

1. 정상 종료 `exit()`
2. 부모 프로세스 요청 `kill()` 
3. 메모리 공간 침범 등 에러 (Error Termination - Fault)
4. 비정상적 에러.. 입출력 실패.. 정의되지 않은 instruction 등 예외상황에 대한 에러 (Abnormal Termination - Exception)

가 있습니다.

### 프로세스 상태도
### Five-State Process Model
프로세스의 상태는 5가지로 볼 수 있습니다.

1. New
2. Ready
3. Running
4. Blocked
5. Terminated

이를 시스템 콜과 연관지어 짚고 넘어가려 합니다.

**new state**인 프로세스가 있으면, 이를 **process list, job queue**에 들어가면서 ready state로 바꿉니다.

이런 **ready state**가 스케줄링에 의해 **dispatch**당하면, **running state**로 변환됩니다.

**running state**에서 주어진 시간을 다 사용했으면, **timeout이** 발생하여 **ready state**로 돌아갑니다.

**block state**는 cpu를 줘도 동작 안하는 상태라고 봐도 무방합니다. (wait이거나, lock이 되어있는 경우)

`wait()`, `sleep()` syscall로 진입할 수 있습니다.

**Running** 상태에서 프로세스가 종료될 수 있는데, 이를 **release**라고 합니다.

위에서 봤던 것처럼 `exit()` `kill()` syscall로 **terminated** 상태로 진입할 수 있습니다.

**terminated(zombie)**는 컴퓨팅 자원을 가질 필요는 없지만, 자원 사용량 통계 정보(PCB), 종료된 이유 등의 정보는 필요해서, 프로세스를 남겨 놓습니다.

만약 `wait()`으로 정보를 수집하면, 완전히 프로세스에서 아웃.

### Five-State Process Model 구현
가장 간단한 방법은 **레디 큐와 블록 큐 2개 사용**하는 것입니다.

블록은 여러 가지의 Event로 인해 wait된 상태입니다.

근데 Event는 유한하므로, Event에 대해서도 큐를 더 쪼갤 수 있다..

이를 **Multiple Blocked Queue**라고 합니다. 공간을 더 쓰지만, 처리 속도가 더 빠릅니다. (시간 복잡도, 공간 복잡도 tradeoff)

### Suspended Processes
프로세스는 메인 메모리에 있어야 실행가능합니다.

**cpu utilization**을 높이기 위해 여러 개의 프로세스를 들여와야 하는데, 계속 프로세스들을 불러오다 보면, 메인 메모리의 공간보다 프로세스들을 더 불러오게 되어 공간에 대한 문제가 생깁니다.

이러한 해결책으로, **suspended processes**라는 것을 사용합니다.

이는  임시로 메인 메모리에서 보조기억장치로 옮겼다가 다시 로드해 메인 메모리 공간을 절약하는 방법입니다.

스와핑에는 디스크 I/O 오버헤드가 발생할 수 있으나, 보통 Block 상태로 전환될 때 I/O로 인해 wait되는 경우가 많습니다. 

cpu가 I/O보다 매우 빠르게 동작하기 때문에, 이렇게 메인 메모리에서 보조기억장치로 옮기는 오버헤드가 크게 느껴지진 않습니다.

이렇게 메인 메모리에서 보조기억장치로 옮기는 행위를 **swap**이라고 하고,

보조기억장치로 나가는 것을 **swap out**, 메인 메모리로 들여오는 것을 **swap in**이라고 합니다.

그렇게 밀려나간 **ready를 suspended ready, sleep을 suspended sleep**라고 합니다.

suspended sleep은 suspended ready로 전환될 수 있습니다.

### process suspension을 하는 이유
process suspension을 하는 이유에 있어서는 여러 가지 원인이 있지만.

공통적으로 메인 메모리 공간을 확보하기 위해서입니다.

1. swapping
2. timing (가끔 실행 하는 프로그램)
3. interactive user request (유저 요청)
4. parent process request (부모 프로세스 요청)
5. other OS reason (문제가 suspect 되면)

등의 원인이 있습니다.

### Process Control Block(PCB)
OS가 프로그램 실행을 위해 내부 정보에 대해 관리가 필요합니다.

이는 프로세스도 마찬가지기에, 모든 프로세스에 대해 정보를 관리해야합니다.

이때 PCB라는 것을 이용합니다.

### PCB의 구성 요소

1. Identifier (정수이고 불변입니다. 0부터 시작합니다.)
2. State, Priority
3. Program Counter
4. Memory pointers (메모리 포인터)
5. Address of memory context (메인 메모리 프로세스의 위치 정보)
6. I/O status information (입출력 장치 정보)
7. Accounting information (자원 통계 정보)

linux는 PCB가 어떻게 구현되어있는지 간단히 짚고 넘어갑시다.

linux은 process descriptor라는 것을 이용해 계층적으로 PCB가 설계되어 있습니다.

이를 이용해 다른 프로세스의 task product와 공유하기가 쉬워지는 기능이 있습니다.

### identifier
**자기 자신(process Identifier), 날 만든 프로세스(parent process), User identifier 3개를 저장**합니다.

추가로, 프로세스 그룹의 식별자도 저장합니다.

### Process State information
time sharing 방식에서 time slice이 발생하면, 다시 프로세스를 재개 시 이에 대한 상태가 저장되어야 하며, 이 말은 register(PC)가 필요하다는 것입니다.

따라서, 상태 값 저장 필드, 레지스터, 중단 시 프로세스 진행상황(상태정보) 등을 PCB에 저장합니다.

### Process Control information
PCB는 스케쥴링에 대한 정보도 저장합니다.

대표적으로 process state, priority 등등을 포함합니다.

그 외에는 
inter-process communication 프로세스 간 통신에 필요한 정보 저장 (signal, message queue 등), 프로세스 권한(process privilege), 메모리 저장 위치, 컴퓨터 자원 정보 등을 포함합니다.

### 각 PCB의 관계
**pcb는 부모 - 자식 관계가 가능합니다.

1대N 구조여서, sibiling(형제) 관계도 존재합니다.**

이는 이중 연결 리스트로 구현됩니다.


