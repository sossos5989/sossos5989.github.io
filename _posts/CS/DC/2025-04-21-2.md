---
title: "[데이터통신] Pulse Code Modulation"
date: "2025-04-21T17:20:00+09:00"
tags: ["CS", "데이터통신"]
categories: 
  - CS
  - 데이터통신
description: "Docker에 대해 알아보자."
layout: "post"
published: true
# image: "/images/sample.jpg"
comments: true
---

## 서론
L1 단계에서 신호를 0과 1로 이루어진 Binary code로 변환하는 Pulse Code Modulation (펄스 부호 변조)에 대해 알아봅시다.

## L1
### Pulse Code Modulation (펄스 부호 변조)
우선, 왜 신호를 0과 1로 나누는 지에 대한 깊은 통찰이 필요합니다.

여러 가지 이유가 있지만, 이유들을 정리하면 이렇습니다.

- 잡읍에 강합니다.
- 구현이 간단하고, 비용이 저렴합니다.
- 디지털 논리(반도체)가 이진이기 때문입니다.
- 동기화(클럭에 맞춰)가 쉽습니다.

물론! 고속 통신에서는 QAM, PAM 등을 써서 상태를 여러 개로 분리하여 1개의 신호에 여러 상태를 담을 수도 있지만, 우선은 binary인 경우에 대해서만 알아봅시다. (따로 포스트 작성 예정입니다.)

Reed-Solomon 코드를 사용해 손실된 청크를 복원 가능하게 함
→ FSK 자체는 신호 손실에 민감할 수 있기 때문

신호를 1/0으로 나눈다면,

- 이더넷 케이블의 경우, 전기 신호를 어떠한 임계값을 기준으로 1/0을 판단할 수 있습니다.
- 무선랜의 경우, 무선신호의 특성(진폭, 주파수, 위상)에서 변조된 신호의 해석을 통한 판별으로 1/0을 판단할 수 있습니다.

L1의 전달 매체로써는 유선과 무선으로 나눌 수 있습니다.

- 유선의 경우, 케이블, 전자(전기적 신호), 빛 등을 이용할 수 있습니다.
- 무선의 경우, 무선랜, 블루투스, 이동통신, 위성 등을 이용할 수 있습니다.

### 아날로그 신호 만들기
소리는 진동이기에, 사인함수 조합으로 나타낼 수 있습니다.

$$
y(t) = A \sin(2\pi f t + \varphi)
$$

- $A$ = 크기 (amplitude)  
- $f$ = 주파수 (frequency), 1초에 몇 번 진동(사이클)?  
- $\varphi$ = 위상 (phase)

### Binary 신호를 전달하자
좋습니다. 그러면 이 binary 코드들을 물리적으로 전송해봅시다.

근데 이 binary 코드에 대한 어떠한 프로토콜이 필요하지 않을까요?

그럴때 쓰이는 프로토콜이 바로 **모스 부호**입니다.

모스 부호는 알파벳 하나하나를 짧은 신호(닷)와 긴 신호(대시)의 조합으로 표현하며, 이 부호들을 통해 알파벳으로 바꾸고, 그 알파벳들을 통해 우리가 **의미 있는 의사소통**을 할 수 있게 됩니다.

### 모스 부호를 전달하자
이러한 Binary 신호들은 소리나, 비트나, 빛(영화 엑시트)등으로 송/수신을 할 수 있겠습니다.

### 실습
실시간 소통도 좋지만, 먼저 소리를 wav파일로 바꾸는 것부터 구현해봅시다.

그전에 wav 파일에 대해 알고 갑시다.

### wav 파일
wav파일은 비압축 형태의 디지털 오디오 파일 포맷입니다.

이는 RIFF (Resource Interchange File Format)구조를 따릅니다.

```
RIFF Chunk (파일 전체)
├── "fmt " Chunk: 포맷 정보 (오디오 형식, 채널 수, 샘플링 속도 등)
├── "data" Chunk: 실제 오디오 데이터 (샘플)
```

쉽게 말해서, **포맷 정보 (samplerate, channel 등), 샘플**로 2개로 나눠 파일을 구성하는 것 정도로만 알면 될 것 같습니다.

용어를 정리하고 넘어갑시다.

> samplerate는 1초에 샘플 개수를 말하는 것입니다.
> precision은 샘플 1개를 몇 비트로 표현할것인지를 말합니다.
> sample width 샘플 하나가 차지하는 바이트 수입니다. $precision \div 8$로 표현할 수 있습니다.
> channels은 몇 개의 독립적인 신호로 나뉘는지를 의미합니다.

좋습니다. 이제 wav파일이 binary로 어떻게 존재하는지를 알아봅시다.

RIFF HEADER(Chunk)


```
52 49 46 46   ; "RIFF"
XX XX XX XX   ; ChunkSize (파일 전체 크기 - 8)
57 41 56 45   ; "WAVE"

66 6D 74 20       ; "fmt "
10 00 00 00       ; 16바이트 (Subchunk1Size = 16, PCM)
01 00             ; PCM 형식 (AudioFormat = 1)
02 00             ; 2채널 (Stereo)
44 AC 00 00       ; 44,100 Hz (0xAC44)
10 B1 02 00       ; ByteRate = 176,400 (0x02B110)
04 00             ; BlockAlign = 4 bytes
10 00             ; 16비트 (BitsPerSample)

64 61 74 61      ; "data"
XX XX XX XX      ; 데이터 크기
YY YY YY YY ...  ; 오디오 샘플 데이터
```

이런 식의 구조를 가진다..! 샘플은 보통 리틀 엔디언으로 저장된다. 그래서 16바이트가 `10 00 00 00`이고, 44,100 Hz가 `0xAC44` 인 것

송신자는 아날로그 신호를 알파벳 모스코드에 매핑해주고, wav파일로 저장하면 된다.

수신자는 반면, wav 파일을 열고, frame 단위로 분할하고, 시작 frame(신호)을 찾고, 이후 신호를 고정된 chunk로 나누고, 각 chunk를 디코딩하여 최종적으로 알파벳. 문장으로 복원하는 과정을 거친다.
