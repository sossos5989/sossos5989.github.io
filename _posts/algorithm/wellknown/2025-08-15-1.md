---
title: "[웰노운] KMP 알고리즘에 대해 알아보자."
date: "2025-08-15T05:00:00+09:00"
tags: ["알고리즘", "웰노운"]
categories:
  - 알고리즘
  - 웰노운
description: "KMP 알고리즘"
layout: "post"
published: true
# image: "/images/sample.jpg"
comments: true
---

## 서론
KMP 알고리즘에 대해 알아보자

## 본론
KMP에 대한 좋은 글은 인터넷에 많이 있으니, 핵심만 알아보자.

결국 KMP 알고리즘은 우리가 원하는 패턴 문자열 $P$의 **prefix**와 **suffix**의 최대 길이를 어떻게 구해야 되는지가 관건이다. 

문자열 $S[0 \dots n-1]$에 대하여 위의 최대 길이를 구해야 한다. 

이러한 길이를 구하기 위해서는 DP를 이용해서 **Subproblem**으로 쪼갤 수 있다.

먼저 **Subproblem**을 정의한다. 이를 $\pi[i]$라고 한다.



### 의사 코드
이를 $O(n)$에 구현할 수 있다. 아니, for문이랑 while문이 안에 있는데 왜 $O(n^2)$가 아니고 $O(n)$이라는 의문점이 존재할 것이다.

왜냐하면, for문과 while문을 따로 분리를 해보면, 각각 $O(n)$의 시간복잡도를 가지는 것을 알 수 있다.

좋다. 이제 의사 코드를 작성해보는데, 의사 코드는 두 포인터를 이용해서도 작성할 수 있으나.

두 포인터의 코드는 어렵기도 하고, 우리는 DP를 이용해 열심히 점화식을 구해왔기에! 이를 이용하여 **Bottom-up DP**를 짜보자.

따라서 최종 코드는 다음과 같다.

```c++
for (int i = 1; i < p.size(); i++) {
    int j = pi[i - 1];

    while (j > 0 && p[i] != p[j])
        j = pi[j - 1];

    pi[i] = j + int(p[i] == p[j]);
} // pi

vector<int> ans;
for (int idx = 0, len = 0; idx < t.size(); idx++) {
    while (len > 0 && t[idx] != p[len])
        len = pi[len - 1];

    len += int(t[idx] == p[len]);

    if (len == p.size()) ans.push_back(idx - p.size() + 1); // 1-based idx
}
```

